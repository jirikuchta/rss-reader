async function api(method, uri, data = null) {
    let init = { method: method };
    if (data) {
        if (method == "GET") {
            let params = new URLSearchParams();
            Object.keys(data).forEach(k => params.append(k, data[k]));
            uri += `?${params.toString()}`;
        }
        else {
            init.body = JSON.stringify(data);
            init.headers = new Headers({ "Content-Type": "application/json" });
        }
    }
    let res = await fetch(uri, init);
    let body = res.status != 204 ? await res.json() : null;
    return {
        ok: res.ok,
        [res.ok ? "data" : "error"]: res.ok ? body : body["error"]
    };
}

const storage = Object.create(null);
function publish(message, publisher, data) {
    let subscribers = storage[message] || [];
    subscribers.forEach((subscriber) => {
        typeof (subscriber) == "function"
            ? subscriber(message, publisher, data)
            : subscriber.handleMessage(message, publisher, data);
    });
}
function subscribe(message, subscriber) {
    if (!(message in storage)) {
        storage[message] = [];
    }
    storage[message].push(subscriber);
}

const counters = new Map();
function init$7() {
    sync$1();
    setInterval(sync$1, 60 * 1000);
}
async function sync$1() {
    let res = await api("GET", "/api/counters/");
    if (!res.ok) {
        return;
    }
    let prevSum = sum();
    counters.clear();
    for (const [id, count] of Object.entries(res.data)) {
        counters.set(Number(id), count);
    }
    prevSum != sum() && publish("counters-updated");
}
function get$3(id) { return counters.get(id); }
function sum() {
    return Array.from(counters.values()).reduce((res, count) => res + count, 0);
}

const subscriptions = new Map();
function init$6() {
    return sync();
}
async function sync() {
    let res = await api("GET", "/api/subscriptions/");
    if (!res.ok) {
        return;
    }
    res.data.forEach(s => subscriptions.set(s.id, s));
    publish("subscriptions-changed");
}
function list$2(categoryId) {
    return Array.from(subscriptions.values())
        .filter(s => !categoryId || categoryId == s.category_id);
}
function get$2(id) { return subscriptions.get(id); }
async function add$1(data) {
    let res = await api("POST", "/api/subscriptions/", data);
    if (!res.ok) {
        return res;
    }
    subscriptions.set(res.data.id, res.data);
    publish("subscriptions-changed");
    return res;
}
async function edit$1(id, data) {
    let res = await api("PATCH", `/api/subscriptions/${id}/`, data);
    if (!res.ok) {
        return res;
    }
    subscriptions.set(res.data.id, res.data);
    publish("subscriptions-changed");
    return res;
}
async function remove$1(id) {
    let res = await api("DELETE", `/api/subscriptions/${id}/`);
    if (!res.ok) {
        return res;
    }
    subscriptions.delete(id);
    publish("subscriptions-changed");
    return res;
}
async function markRead$3(id) {
    let res = await api("POST", `/api/subscriptions/${id}/mark-read/`);
    res.ok && sync$1();
}

const categories = new Map();
async function init$5() {
    let res = await api("GET", "/api/categories/");
    res.ok && res.data.forEach(s => categories.set(s.id, s));
}
function list$1() { return Array.from(categories.values()); }
function get$1(id) { return categories.get(id); }
async function getByName(title, create = false) {
    for (let cat of categories.values()) {
        if (cat.title.trim().toLowerCase() == title.trim().toLowerCase()) {
            return cat;
        }
    }
    if (create) {
        let res = await add({ title });
        if (res.ok) {
            return res.data;
        }
    }
}
async function add(data) {
    let res = await api("POST", "/api/categories/", data);
    if (!res.ok) {
        return res;
    }
    categories.set(res.data.id, res.data);
    publish("categories-changed");
    return res;
}
async function edit(id, data) {
    let res = await api("PATCH", `/api/categories/${id}/`, data);
    if (!res.ok) {
        return res;
    }
    categories.set(res.data.id, res.data);
    publish("categories-changed");
    return res;
}
async function remove(id) {
    let res = await api("DELETE", `/api/categories/${id}/`);
    if (!res.ok) {
        return res;
    }
    categories.delete(id);
    sync();
    publish("categories-changed");
    return res;
}
async function markRead$2(id) {
    let res = await api("POST", `/api/categories/${id}/mark-read/`);
    res.ok && sync$1();
}

function getItem(key) {
    let data = localStorage.getItem(key);
    if (data) {
        return JSON.parse(data);
    }
}
function setItem(key, value) {
    localStorage.setItem(key, JSON.stringify(value));
}

var icons = {
    "check": `<svg viewBox="0 0 16 16"><path fill-rule="evenodd" d="M13.854 3.646a.5.5 0 010 .708l-7 7a.5.5 0 01-.708 0l-3.5-3.5a.5.5 0 11.708-.708L6.5 10.293l6.646-6.647a.5.5 0 01.708 0z" clip-rule="evenodd"/></svg>`,
    "check-all": `<svg viewBox="0 0 16 16"><path fill-rule="evenodd" d="M12.354 3.646a.5.5 0 010 .708l-7 7a.5.5 0 01-.708 0l-3.5-3.5a.5.5 0 11.708-.708L5 10.293l6.646-6.647a.5.5 0 01.708 0z" clip-rule="evenodd"/><path d="M6.25 8.043l-.896-.897a.5.5 0 10-.708.708l.897.896.707-.707zm1 2.414l.896.897a.5.5 0 00.708 0l7-7a.5.5 0 00-.708-.708L8.5 10.293l-.543-.543-.707.707z"/></svg>`,
    "chevron-down": `<svg viewBox="0 0 16 16"><path fill-rule="evenodd" d="M1.646 4.646a.5.5 0 01.708 0L8 10.293l5.646-5.647a.5.5 0 01.708.708l-6 6a.5.5 0 01-.708 0l-6-6a.5.5 0 010-.708z" clip-rule="evenodd"/></svg>`,
    "cross": `<svg viewBox="0 0 16 16"><path fill-rule="evenodd" d="M11.854 4.146a.5.5 0 010 .708l-7 7a.5.5 0 01-.708-.708l7-7a.5.5 0 01.708 0z" clip-rule="evenodd"/><path fill-rule="evenodd" d="M4.146 4.146a.5.5 0 000 .708l7 7a.5.5 0 00.708-.708l-7-7a.5.5 0 00-.708 0z" clip-rule="evenodd"/></svg>`,
    "dots-horizontal": `<svg viewBox="0 0 16 16"><path fill-rule="evenodd" d="M3 9.5a1.5 1.5 0 110-3 1.5 1.5 0 010 3zm5 0a1.5 1.5 0 110-3 1.5 1.5 0 010 3zm5 0a1.5 1.5 0 110-3 1.5 1.5 0 010 3z" clip-rule="evenodd"/></svg>`,
    "pencil": `<svg viewBox="0 0 16 16"><path fill-rule="evenodd" d="M11.293 1.293a1 1 0 011.414 0l2 2a1 1 0 010 1.414l-9 9a1 1 0 01-.39.242l-3 1a1 1 0 01-1.266-1.265l1-3a1 1 0 01.242-.391l9-9zM12 2l2 2-9 9-3 1 1-3 9-9z" clip-rule="evenodd"/><path fill-rule="evenodd" d="M12.146 6.354l-2.5-2.5.708-.708 2.5 2.5-.707.708zM3 10v.5a.5.5 0 00.5.5H4v.5a.5.5 0 00.5.5H5v.5a.5.5 0 00.5.5H6v-1.5a.5.5 0 00-.5-.5H5v-.5a.5.5 0 00-.5-.5H3z" clip-rule="evenodd"/></svg>`,
    "plus": `<svg width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M8 0a1 1 0 0 1 1 1v6h6a1 1 0 1 1 0 2H9v6a1 1 0 1 1-2 0V9H1a1 1 0 0 1 0-2h6V1a1 1 0 0 1 1-1z"/></svg>`,
    "trash": `<svg viewBox="0 0 16 16"><path d="M5.5 5.5A.5.5 0 016 6v6a.5.5 0 01-1 0V6a.5.5 0 01.5-.5zm2.5 0a.5.5 0 01.5.5v6a.5.5 0 01-1 0V6a.5.5 0 01.5-.5zm3 .5a.5.5 0 00-1 0v6a.5.5 0 001 0V6z"/><path fill-rule="evenodd" d="M14.5 3a1 1 0 01-1 1H13v9a2 2 0 01-2 2H5a2 2 0 01-2-2V4h-.5a1 1 0 01-1-1V2a1 1 0 011-1H6a1 1 0 011-1h2a1 1 0 011 1h3.5a1 1 0 011 1v1zM4.118 4L4 4.059V13a1 1 0 001 1h6a1 1 0 001-1V4.059L11.882 4H4.118zM2.5 3V2h11v1h-11z" clip-rule="evenodd"/></svg>`,
    "gear": `<svg viewBox="0 0 16 16" width="16" height="16" fill="currentColor"><path d="M8 4.754a3.246 3.246 0 1 0 0 6.492 3.246 3.246 0 0 0 0-6.492zM5.754 8a2.246 2.246 0 1 1 4.492 0 2.246 2.246 0 0 1-4.492 0z"/><path d="M9.796 1.343c-.527-1.79-3.065-1.79-3.592 0l-.094.319a.873.873 0 0 1-1.255.52l-.292-.16c-1.64-.892-3.433.902-2.54 2.541l.159.292a.873.873 0 0 1-.52 1.255l-.319.094c-1.79.527-1.79 3.065 0 3.592l.319.094a.873.873 0 0 1 .52 1.255l-.16.292c-.892 1.64.901 3.434 2.541 2.54l.292-.159a.873.873 0 0 1 1.255.52l.094.319c.527 1.79 3.065 1.79 3.592 0l.094-.319a.873.873 0 0 1 1.255-.52l.292.16c1.64.893 3.434-.902 2.54-2.541l-.159-.292a.873.873 0 0 1 .52-1.255l.319-.094c1.79-.527 1.79-3.065 0-3.592l-.319-.094a.873.873 0 0 1-.52-1.255l.16-.292c.893-1.64-.902-3.433-2.541-2.54l-.292.159a.873.873 0 0 1-1.255-.52l-.094-.319zm-2.633.283c.246-.835 1.428-.835 1.674 0l.094.319a1.873 1.873 0 0 0 2.693 1.115l.291-.16c.764-.415 1.6.42 1.184 1.185l-.159.292a1.873 1.873 0 0 0 1.116 2.692l.318.094c.835.246.835 1.428 0 1.674l-.319.094a1.873 1.873 0 0 0-1.115 2.693l.16.291c.415.764-.42 1.6-1.185 1.184l-.291-.159a1.873 1.873 0 0 0-2.693 1.116l-.094.318c-.246.835-1.428.835-1.674 0l-.094-.319a1.873 1.873 0 0 0-2.692-1.115l-.292.16c-.764.415-1.6-.42-1.184-1.185l.159-.291A1.873 1.873 0 0 0 1.945 8.93l-.319-.094c-.835-.246-.835-1.428 0-1.674l.319-.094A1.873 1.873 0 0 0 3.06 4.377l-.16-.292c-.415-.764.42-1.6 1.185-1.184l.292.159a1.873 1.873 0 0 0 2.692-1.115l.094-.319z"/></svg>`,
    "stack": `<svg viewBox="0 0 16 16"><path d="m14.12 10.163 1.715.858c.22.11.22.424 0 .534L8.267 15.34a.598.598 0 0 1-.534 0L.165 11.555a.299.299 0 0 1 0-.534l1.716-.858 5.317 2.659c.505.252 1.1.252 1.604 0l5.317-2.66zM7.733.063a.598.598 0 0 1 .534 0l7.568 3.784a.3.3 0 0 1 0 .535L8.267 8.165a.598.598 0 0 1-.534 0L.165 4.382a.299.299 0 0 1 0-.535L7.733.063z"/><path d="m14.12 6.576 1.715.858c.22.11.22.424 0 .534l-7.568 3.784a.598.598 0 0 1-.534 0L.165 7.968a.299.299 0 0 1 0-.534l1.716-.858 5.317 2.659c.505.252 1.1.252 1.604 0l5.317-2.659z"/></svg>`,
    "heart": `<svg viewBox="0 0 16 16"><path d="m8 6.236-.894-1.789c-.222-.443-.607-1.08-1.152-1.595C5.418 2.345 4.776 2 4 2 2.324 2 1 3.326 1 4.92c0 1.211.554 2.066 1.868 3.37.337.334.721.695 1.146 1.093C5.122 10.423 6.5 11.717 8 13.447c1.5-1.73 2.878-3.024 3.986-4.064.425-.398.81-.76 1.146-1.093C14.446 6.986 15 6.131 15 4.92 15 3.326 13.676 2 12 2c-.777 0-1.418.345-1.954.852-.545.515-.93 1.152-1.152 1.595L8 6.236zm.392 8.292a.513.513 0 0 1-.784 0c-1.601-1.902-3.05-3.262-4.243-4.381C1.3 8.208 0 6.989 0 4.92 0 2.755 1.79 1 4 1c1.6 0 2.719 1.05 3.404 2.008.26.365.458.716.596.992a7.55 7.55 0 0 1 .596-.992C9.281 2.049 10.4 1 12 1c2.21 0 4 1.755 4 3.92 0 2.069-1.3 3.288-3.365 5.227-1.193 1.12-2.642 2.48-4.243 4.38z"/></svg>`,
    "heart-fill": `<svg viewBox="0 0 16 16"><path d="M4 1c2.21 0 4 1.755 4 3.92C8 2.755 9.79 1 12 1s4 1.755 4 3.92c0 3.263-3.234 4.414-7.608 9.608a.513.513 0 0 1-.784 0C3.234 9.334 0 8.183 0 4.92 0 2.755 1.79 1 4 1z"/></svg>`
};

const SVGNS = "http://www.w3.org/2000/svg";
function node$4(name, attrs, content, parent) {
    let n = document.createElement(name);
    Object.assign(n, attrs);
    content && text(content, n);
    parent && parent.appendChild(n);
    return n;
}
function clear(node) {
    while (node.firstChild) {
        node.removeChild(node.firstChild);
    }
    return node;
}
function text(txt, parent) {
    let n = document.createTextNode(txt);
    parent && parent.appendChild(n);
    return n;
}
function button(attrs, content, parent) {
    let result = node$4("button", attrs, content, parent);
    if (attrs && attrs.icon) {
        let i = icon(attrs.icon);
        result.insertBefore(i, result.firstChild);
    }
    return result;
}
function svg(name, attrs = {}) {
    let node = document.createElementNS(SVGNS, name);
    for (let name in attrs) {
        node.setAttribute(name, attrs[name]);
    }
    return node;
}
function icon(type, title = "", parent) {
    let str = icons[type];
    if (!str) {
        console.error("Bad icon type '%s'", type);
        return node$4("span", {}, "‽");
    }
    let tmp = node$4("div");
    tmp.innerHTML = str;
    let s = tmp.querySelector("svg");
    if (!s) {
        throw new Error(`Bad icon source for type '${type}'`);
    }
    s.classList.add("icon");
    s.classList.add(`icon-${type}`);
    if (title) {
        let t = svg("title");
        text(title, t);
        s.insertAdjacentElement("afterbegin", t);
    }
    parent && parent.appendChild(s);
    return s;
}
function fragment() {
    return document.createDocumentFragment();
}

const articles = new Map();
async function list(filters) {
    let res = await api("GET", "/api/articles/", filters);
    res.data.forEach(article => {
        article.time_published = new Date(article.time_published);
        articles.set(article.id, article);
    });
    return res.data;
}
async function get(id) {
    if (!articles.has(id)) {
        let res = await api("GET", `/api/articles/${id}/`);
        articles.set(id, res.data);
    }
    return articles.get(id);
}
async function markRead$1(ids) {
    let res = await api("POST", "/api/articles/mark-read/", ids ? { ids } : { all: true });
    if (!res.ok) {
        return;
    }
    articles.forEach(a => {
        if (ids && !ids.includes(a.id)) {
            return;
        }
        articles.set(a.id, Object.assign(a, { read: true }));
    });
    sync$1();
    publish("articles-read");
}

function build$2(subscription) {
    let node = node$4("span", { className: "subscription-icon" });
    node.dataset.content = subscription.title[0];
    let img = new Image();
    img.onload = () => node.appendChild(img);
    img.src = `https://www.google.com/s2/favicons?domain=${subscription.web_url}&alt=feed/`;
    return node;
}

function id() {
    return `i${Math.random().toString(36).substr(2, 9)}`;
}

function labelInput(text, input) {
    let label = node$4("label", {}, text);
    input.required && label.classList.add("required");
    let id$1 = id();
    label.setAttribute("for", id$1);
    input.setAttribute("id", id$1);
    let frag = fragment();
    frag.appendChild(label);
    frag.appendChild(input);
    return frag;
}

let current$1 = null;
class Dialog {
    constructor() {
        this.node = node$4("div", { id: "dialog" });
    }
    open() {
        current$1 === null || current$1 === void 0 ? void 0 : current$1.close();
        current$1 = this;
        document.body.classList.add("with-dialog");
        document.body.appendChild(this.node);
    }
    close() {
        var _a;
        current$1 = null;
        document.body.classList.remove("with-dialog");
        (_a = this.node.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(this.node);
        this.onClose();
    }
    onClose() { }
    closeButton() {
        let button$1 = button({ icon: "cross", className: "close" });
        button$1.addEventListener("click", e => this.close());
        return button$1;
    }
}
async function confirm(text, ok, cancel) {
    let dialog = new Dialog();
    let header = node$4("header", {}, "", dialog.node);
    header.appendChild(dialog.closeButton());
    node$4("h3", {}, text, header);
    let footer = node$4("footer", {}, "", dialog.node);
    let btnOk = button({ type: "submit" }, ok || "OK", footer);
    let btnCancel = button({ type: "button" }, cancel || "Cancel", footer);
    dialog.open();
    return new Promise(resolve => {
        dialog.onClose = () => resolve(false);
        btnOk.addEventListener("click", e => {
            resolve(true);
            dialog.close();
        });
        btnCancel.addEventListener("click", e => dialog.close());
    });
}
window.addEventListener("keydown", e => e.keyCode == 27 && (current$1 === null || current$1 === void 0 ? void 0 : current$1.close()));

class SubscriptionForm {
    constructor(subscription) {
        this._subscription = subscription;
        this._build();
        this.node.addEventListener("submit", this);
    }
    static open(subscription) {
        let dialog = new Dialog();
        let subscriptionForm = new SubscriptionForm(subscription);
        subscriptionForm.afterSubmit = () => dialog.close();
        let header = node$4("header", {}, `${subscription ? "Edit" : "Add"} subscription`, dialog.node);
        header.appendChild(dialog.closeButton());
        dialog.node.appendChild(subscriptionForm.node);
        let footer = node$4("footer", {}, "", dialog.node);
        footer.appendChild(subscriptionForm.submitBtn);
        dialog.open();
    }
    async handleEvent(e) {
        var _a;
        if (e.type == "submit") {
            e.preventDefault();
            let data = {
                title: this._title.value,
                feed_url: this._url.value,
                category_id: (_a = (await getByName(this._category.value, true))) === null || _a === void 0 ? void 0 : _a.id
            };
            let res;
            if (this._subscription) {
                res = await edit$1(this._subscription.id, data);
            }
            else {
                res = await add$1(data);
            }
            this._validate(res);
            this.node.checkValidity() && this.afterSubmit();
        }
    }
    afterSubmit() { }
    _build() {
        this.node = node$4("form", { id: id() });
        this.node.noValidate = true;
        this.submitBtn = button({ type: "submit" }, "Submit");
        this.submitBtn.setAttribute("form", this.node.id);
        this._title = node$4("input", { type: "text", required: "true" });
        this._url = node$4("input", { type: "url", required: "true" });
        this._category = node$4("input", { type: "text" });
        if (this._subscription) {
            this._title.value = this._subscription.title;
            this._url.value = this._subscription.feed_url;
            this._url.disabled = true;
            if (this._subscription.category_id) {
                let cat = get$1(this._subscription.category_id);
                cat && (this._category.value = cat.title);
            }
        }
        this._subscription && this.node.appendChild(labelInput("Title", this._title));
        this.node.appendChild(labelInput("Feed URL", this._url));
        this.node.appendChild(labelInput("Category", this._category));
        let categoryList = node$4("datalist", { id: id() });
        list$1().forEach(c => node$4("option", { value: c.title }, c.title, categoryList));
        this._category.setAttribute("list", categoryList.id);
        this.node.appendChild(categoryList);
    }
    _validate(res) {
        var _a;
        this._clearValidation();
        switch ((_a = res.error) === null || _a === void 0 ? void 0 : _a.code) {
            case "missing_field":
                let msg = "Please fill out this field.";
                res.error.field == "title" && this._title.setCustomValidity(msg);
                res.error.field == "uri" && this._url.setCustomValidity(msg);
                break;
            case "invalid_field":
                res.error.field == "categoryId" && this._category.setCustomValidity("Category not found.");
                break;
            case "parser_error":
                this._url.setCustomValidity("No valid RSS/Atom feed found.");
                break;
            case "already_exists":
                this._url.setCustomValidity("You are already subscribed to this feed.");
                break;
            case "ambiguous_feed_url":
                this._feedSelect = node$4("select");
                node$4("option", { value: this._url.value }, "Select feed…", this._feedSelect);
                res.error.links.forEach(l => node$4("option", { value: l.href }, l.title || l.href, this._feedSelect));
                this._feedSelect.addEventListener("change", e => this._url.value = this._feedSelect.value);
                this._url.parentNode.insertBefore(this._feedSelect, this._url.nextSibling);
                this._feedSelect.setCustomValidity("Provided URL is a HTML page referencing multiple feeds.");
                break;
        }
        this.node.classList.toggle("invalid", !this.node.checkValidity());
        this.node.reportValidity();
    }
    _clearValidation() {
        var _a;
        (_a = this._feedSelect) === null || _a === void 0 ? void 0 : _a.remove();
        this._title.setCustomValidity("");
        this._url.setCustomValidity("");
        this._category.setCustomValidity("");
    }
}

class CategoryForm {
    constructor(category) {
        this._category = category;
        this._build();
        this.node.addEventListener("submit", this);
    }
    static open(category) {
        let dialog = new Dialog();
        let categoryForm = new CategoryForm(category);
        categoryForm.afterSubmit = () => dialog.close();
        let header = node$4("header", {}, "Edit category", dialog.node);
        header.appendChild(dialog.closeButton());
        dialog.node.appendChild(categoryForm.node);
        let footer = node$4("footer", {}, "", dialog.node);
        footer.appendChild(categoryForm.submitBtn);
        dialog.open();
    }
    async handleEvent(e) {
        if (e.type == "submit") {
            e.preventDefault();
            let res = await edit(this._category.id, {
                title: this._title.value
            });
            this._validate(res);
            this.node.checkValidity() && this.afterSubmit();
        }
    }
    afterSubmit() { }
    _build() {
        this.node = node$4("form", { id: id() });
        this.node.noValidate = true;
        this.submitBtn = button({ type: "submit" }, "Submit");
        this.submitBtn.setAttribute("form", this.node.id);
        this._title = node$4("input", { type: "text", required: "true", value: this._category.title });
        this.node.appendChild(labelInput("Title", this._title));
    }
    _validate(res) {
        var _a;
        this._clearValidation();
        switch ((_a = res.error) === null || _a === void 0 ? void 0 : _a.code) {
            case "missing_field":
                this._title.setCustomValidity("Please fill out this field.");
                break;
            case "already_exists":
                this._title.setCustomValidity(`Title already exists.`);
                break;
        }
        this.node.classList.toggle("invalid", !this.node.checkValidity());
        this.node.reportValidity();
    }
    _clearValidation() {
        this._title.setCustomValidity("");
    }
}

const PROLOG = '<?xml version="1.0" encoding="UTF-8"?>';
function parse(opml) {
    let parser = new DOMParser();
    let doc = parser.parseFromString(opml, "application/xml");
    let nodes = Array.from(doc.querySelectorAll("outline"))
        .filter(node => node.getAttribute("type") == "rss");
    return nodes.map(node => {
        var _a;
        return ({
            title: node.getAttribute("title"),
            xmlUrl: node.getAttribute("xmlUrl"),
            webUrl: node.getAttribute("webUrl"),
            category: ((_a = node.closest("body > outline:not([type=rss])")) === null || _a === void 0 ? void 0 : _a.getAttribute("title")) || null
        });
    });
}
function serialize() {
    let doc = document.implementation.createDocument(null, null, null);
    let body = doc.createElement("body");
    list$1()
        .forEach(c => body.appendChild(buildCategory$1(doc, c)));
    list$2()
        .filter(s => !s.category_id)
        .forEach(s => body.appendChild(buildSubscription(doc, s)));
    let root = doc.createElement("opml");
    root.setAttribute("version", "1.0");
    doc.appendChild(root);
    root.appendChild(doc.createElement("head"));
    root.appendChild(body);
    return `${PROLOG}${(new XMLSerializer()).serializeToString(doc)}`;
}
function buildCategory$1(doc, data) {
    let node = doc.createElement("outline");
    node.setAttribute("text", data.title);
    node.setAttribute("title", data.title);
    list$2(data.id)
        .forEach(s => node.appendChild(buildSubscription(doc, s)));
    return node;
}
function buildSubscription(doc, data) {
    let node = doc.createElement("outline");
    node.setAttribute("type", "rss");
    node.setAttribute("text", data.title);
    node.setAttribute("title", data.title);
    node.setAttribute("title", data.title);
    node.setAttribute("xmlUrl", data.feed_url);
    data.web_url && node.setAttribute("webUrl", data.web_url);
    return node;
}

function open() {
    let dialog = new Dialog();
    let header = node$4("header", {}, "Settings", dialog.node);
    header.appendChild(dialog.closeButton());
    dialog.node.appendChild(buildOPML());
    dialog.open();
}
function buildOPML() {
    let node = node$4("section", { id: "opml" });
    node$4("h3", {}, "Import from OPML file", node);
    let droparea = node$4("label", { className: "droparea" }, "Click to choose OPML file or drop one here", node);
    droparea.addEventListener("dragover", e => e.preventDefault());
    droparea.addEventListener("drop", e => e.preventDefault());
    let input = node$4("input", { type: "file" }, "", droparea);
    input.addEventListener("input", onFileInput);
    node$4("h3", {}, "Export to OPML file", node);
    let href = window.URL.createObjectURL(new Blob([serialize()], { type: "application/xml" }));
    node$4("a", { href, download: "subscriptions.opml" }, "Download OPML file", node);
    return node;
}
function onFileInput(e) {
    let reader = new FileReader();
    reader.onload = evt => processImport(parse(evt.target.result));
    reader.readAsText(e.target.files[0]);
}
async function processImport(items) {
    for (let item of items) {
        let category = item.category ? (await getByName(item.category, true)) : null;
        let data = {
            feed_url: item.xmlUrl || item.webUrl || ""
        };
        item.title && (data["title"] = item.title);
        item.webUrl && (data["web_url"] = item.webUrl);
        category && (data["category_id"] = category.id);
        await add$1(data);
    }
}

const PAD = 8;
let current = null;
function preventOverflow(position, type, avail) {
    let overflow = 0;
    switch (type) {
        case "left":
            overflow = PAD - position.left;
            if (overflow > 0) {
                position.left += overflow;
                position.right += overflow;
            }
            break;
        case "right":
            overflow = position.right + PAD - avail[0];
            if (overflow > 0) {
                position.left -= overflow;
                position.right -= overflow;
            }
            break;
        case "bottom":
            overflow = position.bottom + PAD - avail[1];
            if (overflow > 0) {
                position.top -= overflow;
                position.bottom -= overflow;
            }
            break;
        case "top":
            overflow = PAD - position.top;
            if (overflow > 0) {
                position.top += overflow;
                position.bottom += overflow;
            }
            break;
    }
}
function position(windowNode, referenceNode, type, offset) {
    const referenceRect = referenceNode.getBoundingClientRect();
    const avail = [window.innerWidth, window.innerHeight];
    const windowSize = [windowNode.offsetWidth, windowNode.offsetHeight];
    switch (type) {
        case "side":
            offset = offset || [8, 0];
            break;
        case "below":
            offset = offset || [0, 8];
            break;
        default:
            offset = offset || [0, 0];
            break;
    }
    let targetPosition = {
        left: referenceRect.left + offset[0],
        top: referenceRect.top + offset[1],
        right: 0,
        bottom: 0
    };
    switch (type) {
        case "side":
            {
                let wantedLeft = referenceRect.left - offset[0] - windowSize[0];
                if (wantedLeft >= PAD) {
                    targetPosition.left = wantedLeft;
                }
                else {
                    targetPosition.left = referenceRect.right + offset[0];
                }
            }
            break;
        case "below":
            {
                let wantedTop = referenceRect.bottom + offset[1];
                if (wantedTop + windowSize[1] <= avail[1] - PAD) {
                    targetPosition.top = wantedTop;
                }
                else {
                    targetPosition.top = referenceRect.top - offset[1] - windowSize[1];
                }
            }
            break;
    }
    targetPosition.right = targetPosition.left + windowSize[0];
    targetPosition.bottom = targetPosition.top + windowSize[1];
    preventOverflow(targetPosition, "right", avail);
    preventOverflow(targetPosition, "left", avail);
    preventOverflow(targetPosition, "bottom", avail);
    preventOverflow(targetPosition, "top", avail);
    windowNode.style.left = `${targetPosition.left}px`;
    windowNode.style.top = `${targetPosition.top}px`;
}
class Popup {
    constructor() {
        this.node = node$4("div", { className: "popup" });
        this.node.addEventListener("mousedown", e => e.stopPropagation());
    }
    open(target, pos, offset) {
        current === null || current === void 0 ? void 0 : current.close();
        current = this;
        document.body.appendChild(this.node);
        this.anchorTo(target, pos, offset);
    }
    close() {
        var _a;
        current = null;
        (_a = this.node.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(this.node);
        this.onClose();
    }
    anchorTo(node, type, offset) {
        position(this.node, node, type, offset);
    }
    onClose() { }
    addMenuItem(title, icon, onClick) {
        let node = button({ icon: icon }, title, this.node);
        node.addEventListener("click", e => {
            this.close();
            onClick();
        });
    }
}
class PopupMenu extends Popup {
    constructor() {
        super();
        this.node.classList.add("popup-menu");
    }
    addItem(title, icon, onClick) {
        let node = button({ icon: icon }, title, this.node);
        node.addEventListener("click", e => {
            this.close();
            onClick();
        });
        return node;
    }
}
window.addEventListener("keydown", e => e.keyCode == 27 && (current === null || current === void 0 ? void 0 : current.close()));
document.addEventListener("mousedown", e => current === null || current === void 0 ? void 0 : current.close());

const SELECTED_CSS_CLASS$1 = "is-selected";
const node$3 = node$4("nav");
let selected$1;
let items$1 = [];
const scroll = node$4("div", { className: "scroll" }, "", node$3);
function init$4() {
    buildList();
    node$3.appendChild(buildFooter());
    // FIXME: may cause two consecutive builds
    subscribe("subscriptions-changed", buildList);
    subscribe("categories-changed", buildList);
    subscribe("counters-updated", updateCounters);
}
async function buildList() {
    clear(scroll);
    items$1 = [];
    let list;
    list = node$4("ul", {}, "", scroll);
    let allItem = new AllItem();
    list.appendChild(allItem.node);
    if (list$2().some(s => s.favorite)) {
        buildFavorites();
    }
    node$4("h3", {}, "Feeds", scroll);
    list$1().forEach(c => buildCategory(c));
    list = node$4("ul", {}, "", scroll);
    list$2()
        .filter(s => !s.category_id)
        .forEach(s => list.appendChild(new SubscriptionItem(s).node));
    updateCounters();
    select(allItem);
}
function buildFooter() {
    let footer = node$4("footer");
    let addBtn = button({ icon: "plus" }, "", footer);
    addBtn.addEventListener("click", e => SubscriptionForm.open());
    let settingsBtn = button({ icon: "gear" }, "", footer);
    settingsBtn.addEventListener("click", e => open());
    return footer;
}
function buildFavorites() {
    node$4("h3", {}, "Favorites", scroll);
    list$2().filter(s => s.favorite).forEach(s => {
        scroll.appendChild(new SubscriptionItem(s).node);
    });
}
function buildCategory(category) {
    let list = node$4("ul", {}, "", scroll);
    let item = new CategoryItem(category);
    list.appendChild(item.node);
    items$1.push(item);
    list$2()
        .filter(s => s.category_id == category.id)
        .forEach(s => list.appendChild(new SubscriptionItem(s).node));
}
function select(item) {
    var _a;
    (_a = node$3.querySelector(`.${SELECTED_CSS_CLASS$1}`)) === null || _a === void 0 ? void 0 : _a.classList.remove(SELECTED_CSS_CLASS$1);
    item.node.classList.add(SELECTED_CSS_CLASS$1);
    selected$1 = item;
    publish("nav-item-selected");
}
function updateCounters() {
    items$1.forEach(i => i.updateCounter());
}
class Item$1 {
    constructor(data) {
        this._data = data;
        this.build();
        this.updateCounter();
        items$1.push(this);
    }
    get data() {
        return this._data;
    }
    get node() {
        return this._node;
    }
    updateCounter() { }
    ;
    handleEvent(e) {
        e.preventDefault();
        switch (e.type) {
            case "contextmenu":
                showContextMenu(this, e);
                break;
            case "click":
                select(this);
                break;
        }
    }
    build() {
        let node = node$4("li");
        let counter = node$4("span", { className: "count" });
        node.appendChild(node$4("span", { className: "title" }, this.data.title));
        node.appendChild(counter);
        node.addEventListener("click", this);
        node.addEventListener("contextmenu", this);
        this._node = node;
        this._counter = counter;
    }
}
class AllItem extends Item$1 {
    constructor() { super({ title: "All articles" }); }
    updateCounter() {
        clear(this._counter);
        let count = sum();
        count && this._counter.appendChild(text(`${count}`));
    }
    build() {
        super.build();
        this.node.insertAdjacentElement("afterbegin", icon("stack"));
    }
}
class CategoryItem extends Item$1 {
    get data() {
        return this._data;
    }
    updateCounter() {
        clear(this._counter);
        let count = list$2()
            .filter(s => s.category_id == this.data.id)
            .reduce((total, s) => total + (get$3(s.id) || 0), 0);
        count && this._counter.appendChild(text(`${count}`));
    }
    handleEvent(e) {
        if (e.type == "click" && e.currentTarget == this._opener) {
            e.stopPropagation();
            return this.toggle();
        }
        super.handleEvent(e);
    }
    build() {
        super.build();
        this._opener = button({ icon: "chevron-down", className: "plain btn-chevron" });
        this._opener.addEventListener("click", this);
        this.node.classList.add("category");
        this.node.insertAdjacentElement("afterbegin", this._opener);
    }
    toggle() {
        this.node.classList.toggle("is-collapsed");
    }
}
class SubscriptionItem extends Item$1 {
    get data() {
        return this._data;
    }
    updateCounter() {
        clear(this._counter);
        let count = get$3(this.data.id);
        count && this._counter.appendChild(text(`${count}`));
    }
    build() {
        super.build();
        this.node.insertAdjacentElement("afterbegin", build$2(this.data));
    }
}
function showContextMenu(item, e) {
    e.preventDefault();
    let menu = new PopupMenu();
    if (item instanceof AllItem) {
        menu.addItem("Mark as read", "check-all", () => markRead$1());
    }
    if (item instanceof CategoryItem) {
        menu.addItem("Mark as read", "check-all", () => markRead$2(item.data.id));
        menu.addItem("Edit category", "pencil", () => CategoryForm.open(item.data));
        menu.addItem("Delete category", "trash", () => deleteCategory(item.data));
    }
    if (item instanceof SubscriptionItem) {
        menu.addItem("Mark as read", "check-all", () => markRead$3(item.data.id));
        menu.addItem(`${item.data.favorite ? "Remove from" : "Add to"} favorites`, item.data.favorite ? "heart-fill" : "heart", () => edit$1(item.data.id, { favorite: !item.data.favorite }));
        menu.addItem("Edit subscription", "pencil", () => SubscriptionForm.open(item.data));
        menu.addItem("Unsubscribe", "trash", () => deleteSubscription(item.data));
    }
    menu.open(item.node, "below", [
        e.clientX - item.node.getBoundingClientRect().left + 8,
        e.clientY - item.node.getBoundingClientRect().bottom + 8
    ]);
}
async function deleteCategory(category) {
    if (await confirm(`Delete category ${category.title}? Any nested subscriptions will be moved to uncategorized.`)) {
        remove(category.id);
    }
}
async function deleteSubscription(subscription) {
    if (await confirm(`Unsubscribe from ${subscription.title}?`)) {
        remove$1(subscription.id);
    }
}

function date(d) {
    let today = new Date;
    let date_str = d.toLocaleDateString();
    let time_str = d.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });
    if (d.getMonth() == today.getMonth() && d.getFullYear() == today.getFullYear()) {
        if (d.getDate() == today.getDate()) {
            date_str = "today";
        }
        if (d.getDate() == today.getDate() - 1) {
            date_str = "yesterday";
        }
    }
    return `${date_str} ${time_str}`;
}

const SELECTED_CSS_CLASS = "is-selected";
const READ_CSS_CLASS = "is-read";
const node$2 = node$4("section", { "id": "list" });
let items = [];
let markReadTimeout;
const showMoreObserver = new IntersectionObserver(entries => entries[0].isIntersecting && build$1(), { root: node$2, rootMargin: "0% 0% 20% 0%" });
function init$3() {
    build$1();
    subscribe("nav-item-selected", () => {
        clear(node$2);
        items = [];
        build$1();
    });
    subscribe("articles-read", () => items.forEach(i => i.sync()));
    node$2.addEventListener("scroll", () => {
        clearTimeout(markReadTimeout);
        markReadTimeout = setTimeout(() => markRead(), 300);
    });
    document.body.addEventListener("keydown", e => {
        if (["Alt", "Control", "Shift", "OS", "Meta"].some(key => e.getModifierState(key))) {
            return;
        }
        if (e.isComposing) {
            return;
        }
        let selectedIndex = items.findIndex(i => i.isSelected);
        if (selectedIndex == -1) {
            return;
        }
        if (e.code == "ArrowRight") {
            let item = items[selectedIndex + 1];
            item && (item.isSelected = true) && item.focus();
        }
        if (e.code == "ArrowLeft") {
            let item = items[selectedIndex - 1];
            item && (item.isSelected = true) && item.focus();
        }
    });
}
function selected() {
    var _a;
    return (_a = items.find(i => i.isSelected)) === null || _a === void 0 ? void 0 : _a.id;
}
async function build$1() {
    let data = await list(getFilters());
    data.forEach(article => {
        let item = new Item(article);
        item.node.addEventListener("click", () => item.isSelected = true);
        node$2.appendChild(item.node);
        items.push(item);
    });
    showMoreObserver.disconnect();
    data.length && showMoreObserver.observe(items[items.length - 1].node);
}
function getFilters() {
    let filters = {
        unread_only: true,
        offset: items.filter(i => !i.isRead).length
    };
    if (selected$1 instanceof SubscriptionItem) {
        filters["subscription_id"] = selected$1.data.id;
    }
    if (selected$1 instanceof CategoryItem) {
        filters["category_id"] = selected$1.data.id;
    }
    return filters;
}
function markRead() {
    let markReadItems = items.filter(i => !i.isRead && i.node.getBoundingClientRect().bottom <= 0);
    markReadItems.length && markRead$1(markReadItems.map(i => i.id));
}
class Item {
    constructor(data) {
        this.data = data;
        this.node = this.build();
    }
    get id() {
        return this.data.id;
    }
    get isRead() {
        return this.node.classList.contains(READ_CSS_CLASS);
    }
    set isRead(value) {
        this.node.classList.toggle(READ_CSS_CLASS, value);
    }
    get isSelected() {
        return this.node.classList.contains(SELECTED_CSS_CLASS);
    }
    set isSelected(value) {
        items.forEach(i => i.node.classList.toggle(SELECTED_CSS_CLASS, i.id == this.id ? value : (value ? false : i.isSelected)));
        value && publish("article-selected");
    }
    focus() {
        let rect = this.node.getBoundingClientRect();
        if (rect.y <= 0 || rect.bottom > node$2.clientHeight) {
            (this.node.previousElementSibling || this.node).scrollIntoView(true);
        }
    }
    async sync() {
        this.data = await get(this.data.id);
        this.isRead = this.data.read;
    }
    build() {
        let subscription = get$2(this.data.subscription_id);
        let elm = node$4("article");
        elm.dataset.id = this.id.toString();
        let header = node$4("header", {}, "", elm);
        header.appendChild(build$2(subscription));
        header.appendChild(node$4("h6", {}, subscription.title || subscription.feed_url));
        header.appendChild(node$4("time", {}, date(this.data.time_published)));
        this.data.image_url && elm.appendChild(node$4("img", { src: this.data.image_url }));
        elm.appendChild(node$4("h3", {}, this.data.title));
        elm.appendChild(node$4("p", {}, this.data.summary));
        return elm;
    }
}

const node$1 = node$4("section", { "id": "detail" });
function init$2() {
    build();
    subscribe("article-selected", build);
}
async function build() {
    clear(node$1);
    node$1.scrollTo(0, 0);
    let articleId = selected();
    if (!articleId) {
        return;
    }
    let article = await get(articleId);
    if (!article) {
        return;
    }
    let frag = fragment();
    let header = node$4("header", {}, "", frag);
    let title = node$4("h1", {}, "", header);
    node$4("a", { href: article.url, target: "_blank", rel: "noopener noreferrer" }, article.title, title);
    let content = node$4("div", {}, "", frag);
    content.innerHTML = article.content || article.summary || "";
    node$1.appendChild(frag);
    !article.read && markRead$1([article.id]);
}

let node = document.querySelector("main");
async function init$1() {
    init$4();
    init$3();
    init$2();
    node.appendChild(node$3);
    node.appendChild(node$2);
    node.appendChild(node$1);
    new Resizer(node$3, "navWidth");
    new Resizer(node$2, "articlesWidth");
}
class Resizer {
    constructor(node, storageId) {
        this._node = node;
        this._storageId = storageId;
        this._build();
    }
    _build() {
        let node = node$4("div", { className: "resizer" });
        node.addEventListener("mousedown", this);
        this._node.insertAdjacentElement("afterend", node);
        let width = getItem(this._storageId);
        width && (this._node.style.flexBasis = `${width}%`);
    }
    handleEvent(ev) {
        switch (ev.type) {
            case "mousedown":
                document.addEventListener("mousemove", this);
                document.addEventListener("mouseup", this);
                document.body.style.userSelect = "none";
                break;
            case "mouseup":
                document.removeEventListener("mousemove", this);
                document.removeEventListener("mouseup", this);
                document.body.style.userSelect = "";
                let width = (this._node.offsetWidth / document.body.offsetWidth) * 100;
                setItem(this._storageId, width);
                break;
            case "mousemove":
                this._resize(ev.clientX);
                break;
        }
    }
    _resize(pos) {
        let widthPx = pos - this._node.offsetLeft;
        let widthPerc = (widthPx / document.body.offsetWidth) * 100;
        this._node.style.flexBasis = `${widthPerc}%`;
    }
}

async function init() {
    await init$5();
    await init$6();
    await init$6();
    init$7();
    init$1();
}
init();
